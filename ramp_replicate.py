# -*- coding: utf-8 -*-

from scipy import signal
import nidaqmx as nq
from nidaqmx import *
import numpy as np

"""
created on Mon Jun 14 09:57:23 2021 by bjraiv23

class reads ramp generated by box then emulates it with ao and a numpy array

notes:
    - possible to emulate ramp using linspace segments that evenly space the fabry perot peak (probably a bad idea)
        - use polynomial scale to convert ramp voltage to frequency
        - use residual to find best fit
    - best practice would be to record both the ramp (to find max and min) and the associated square wave (to find frequency)
    - gain more precise dither control to account in measurement? or just use averaging <- depends on drift issues
    - for pass through use analog switches that are digitally actuated by the computer
        - need to look at on resistance, switching time, leakage to make sure that such a switch would not affect measured values
        - short circuit protection is needed as well
    - use fabry perot peaks and pid to adjust voltage ramp continuously
        - use scipy.signal.find_peaks    
    - add function to run full cycle once then loop in a different class
    - add a scale for index ==> time
"""

class Ramp_Replicate():
    
    def __init__(self, in_channel = 'ai0', out_channel = 'ao0', ctr_channel = 'ctr0', freq = 100000):
        
        '''
        Creates ramp replication object, by default the ramp signal is routed through the AO channel

        Returns
        -------
        None.
        '''
        # computer is initially in pass-through mode
        self.computer_control = False
        
        # set sampling frequency
        self.sample_frequency = freq
        
        # pre-analysis these values are none-type
        self.ramp = None
        self.max = None
        self.min = None
        self.ramp_samples = None
        self.ramp_recording = None
        self.volts_to_MHz = None
        
## need to add parameters to store PID tuning data
        
        # create tasks for reading and writing
        self.read_task = nq.Task()
        self.ramp_freq_task = nq.Task()
        self.write_task = nq.Task()
        
        # add specified (or default) channels to respective tasks
        self.read_task.ai_channels.add_ai_voltage_chan('NI_PCIe-6351/' + in_channel)
        self.ramp_freq_task.ci_channels.add_ci_pulse_chan_freq('NI_PCIe-6351/' + ctr_channel)
        self.write_task.ao_channels.add_ao_voltage_chan('NI_PCIe-6351/' + out_channel)
        
        # expose in and out streams
        self.in_stream = nq._task_modules.in_stream.InStream(self.read_task)
        self.freq_stream = nq._task_modules.in_stream.InStream(self.ramp_freq_task)
        self.out_stream = nq._task_modules.out_stream.OutStream(self.write_task)
        
        # create singlechannel/counter reader/writer
        self.reader = nq.stream_readers.AnalogSingleChannelReader(self.in_stream)
        self.freq_reader = nq.stream_readers.CounterReader(self.freq_stream)
        self.writer = nq.stream_writers.AnalogSingleChannelWriter(self.out_stream)
        
        # set sample clock frequency for tasks
        self.read_task.timing.samp_clk_rate(val = 100000)
        self.read_task.timing.cfg_change_detection_timing(rising_edge_chan='NI_PCIe-6351/' + ctr_channel)
        
        self.ramp_freq_task.timing.samp_clk_rate(1000)
        self.ramp_freq_task.timing.cfg_samp_clk_timing(1000)
        
        self.write_task.timing.samp_clk_rate(100000)
    
    def __str__(self):
        return ''

    def read_ramp(self, duration = 10):
        '''
        - Reads data from the ramp output on an AI channel over given time period
          (must be several full cycles)
        - Measures the frequency, maximum and minimum values of the ramp
        - Initializes null values from __init__
        '''
        # create numpy arrays based on sampling frequency/time
        self.ramp_samples = duration * self.sample_frequency
        self.ramp_recording = np.empty(self.ramp_samples)
        self.freq_recording = np.empty(duration*1000)
        self.duty_cycles_recording = np.empty(duration*1000)
        
        # read ramp data
        self.reader.read_many_sample(self.ramp_recording, self.ramp_samples)
        self.freq_reader.read_many_sample_pulse_frequency(self.freq_recording, self.duty_cycles_recording)
        
        print(self.freq_recording)
        print(self.duty_cycles_recording)
        
        
        

        
    def enable_emulation(self, val):
        self.computer_control = val
        return self.computer_control        
    def modulate(self, func):
        return
if __name__ == "__main__":
    test = Ramp_Replicate(in_channel='ai2')
    test.read_ramp()
